{"ast":null,"code":"import { jsx } from 'react/jsx-runtime';\nimport React from 'react';\nimport * as tweens from 'tween-functions';\nfunction degreesToRads(degrees) {\n  return degrees * Math.PI / 180;\n}\nfunction randomRange(min, max) {\n  return min + Math.random() * (max - min);\n}\nfunction randomInt(min, max) {\n  return Math.floor(min + Math.random() * (max - min + 1));\n}\nvar ParticleShape;\n(function (ParticleShape) {\n  ParticleShape[ParticleShape[\"Circle\"] = 0] = \"Circle\";\n  ParticleShape[ParticleShape[\"Square\"] = 1] = \"Square\";\n  ParticleShape[ParticleShape[\"Strip\"] = 2] = \"Strip\";\n})(ParticleShape || (ParticleShape = {}));\nvar RotationDirection;\n(function (RotationDirection) {\n  RotationDirection[RotationDirection[\"Positive\"] = 1] = \"Positive\";\n  RotationDirection[RotationDirection[\"Negative\"] = -1] = \"Negative\";\n})(RotationDirection || (RotationDirection = {}));\nclass Particle {\n  constructor(context, getOptions, x, y) {\n    this.getOptions = getOptions;\n    const {\n      colors,\n      initialVelocityX,\n      initialVelocityY\n    } = this.getOptions();\n    this.context = context;\n    this.x = x;\n    this.y = y;\n    this.w = randomRange(5, 20);\n    this.h = randomRange(5, 20);\n    this.radius = randomRange(5, 10);\n    this.vx = typeof initialVelocityX === 'number' ? randomRange(-initialVelocityX, initialVelocityX) : randomRange(initialVelocityX.min, initialVelocityX.max);\n    this.vy = typeof initialVelocityY === 'number' ? randomRange(-initialVelocityY, 0) : randomRange(initialVelocityY.min, initialVelocityY.max);\n    this.shape = randomInt(0, 2);\n    this.angle = degreesToRads(randomRange(0, 360));\n    this.angularSpin = randomRange(-0.2, 0.2);\n    this.color = colors[Math.floor(Math.random() * colors.length)];\n    this.rotateY = randomRange(0, 1);\n    this.rotationDirection = randomRange(0, 1) ? RotationDirection.Positive : RotationDirection.Negative;\n  }\n  update() {\n    const {\n      gravity,\n      wind,\n      friction,\n      opacity,\n      drawShape\n    } = this.getOptions();\n    this.x += this.vx;\n    this.y += this.vy;\n    this.vy += gravity;\n    this.vx += wind;\n    this.vx *= friction;\n    this.vy *= friction;\n    if (this.rotateY >= 1 && this.rotationDirection === RotationDirection.Positive) {\n      this.rotationDirection = RotationDirection.Negative;\n    } else if (this.rotateY <= -1 && this.rotationDirection === RotationDirection.Negative) {\n      this.rotationDirection = RotationDirection.Positive;\n    }\n    const rotateDelta = 0.1 * this.rotationDirection;\n    this.rotateY += rotateDelta;\n    this.angle += this.angularSpin;\n    this.context.save();\n    this.context.translate(this.x, this.y);\n    this.context.rotate(this.angle);\n    this.context.scale(1, this.rotateY);\n    this.context.rotate(this.angle);\n    this.context.beginPath();\n    this.context.fillStyle = this.color;\n    this.context.strokeStyle = this.color;\n    this.context.globalAlpha = opacity;\n    this.context.lineCap = 'round';\n    this.context.lineWidth = 2;\n    if (drawShape && typeof drawShape === 'function') {\n      drawShape.call(this, this.context);\n    } else {\n      switch (this.shape) {\n        case ParticleShape.Circle:\n          {\n            this.context.beginPath();\n            this.context.arc(0, 0, this.radius, 0, 2 * Math.PI);\n            this.context.fill();\n            break;\n          }\n        case ParticleShape.Square:\n          {\n            this.context.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);\n            break;\n          }\n        case ParticleShape.Strip:\n          {\n            this.context.fillRect(-this.w / 6, -this.h / 2, this.w / 3, this.h);\n            break;\n          }\n      }\n    }\n    this.context.closePath();\n    this.context.restore();\n  }\n}\nclass ParticleGenerator {\n  constructor(canvas, getOptions) {\n    this.x = 0;\n    this.y = 0;\n    this.w = 0;\n    this.h = 0;\n    this.lastNumberOfPieces = 0;\n    this.tweenInitTime = Date.now();\n    this.particles = [];\n    this.particlesGenerated = 0;\n    this.removeParticleAt = i => {\n      this.particles.splice(i, 1);\n    };\n    this.getParticle = () => {\n      const newParticleX = randomRange(this.x, this.w + this.x);\n      const newParticleY = randomRange(this.y, this.h + this.y);\n      return new Particle(this.context, this.getOptions, newParticleX, newParticleY);\n    };\n    this.animate = () => {\n      const {\n        canvas,\n        context,\n        particlesGenerated,\n        lastNumberOfPieces\n      } = this;\n      const {\n        run,\n        recycle,\n        numberOfPieces,\n        debug,\n        tweenFunction,\n        tweenDuration\n      } = this.getOptions();\n      if (!run) {\n        return false;\n      }\n      const nP = this.particles.length;\n      const activeCount = recycle ? nP : particlesGenerated;\n      const now = Date.now();\n      // Initial population\n      if (activeCount < numberOfPieces) {\n        // Use the numberOfPieces prop as a key to reset the easing timing\n        if (lastNumberOfPieces !== numberOfPieces) {\n          this.tweenInitTime = now;\n          this.lastNumberOfPieces = numberOfPieces;\n        }\n        const {\n          tweenInitTime\n        } = this;\n        // Add more than one piece per loop, otherwise the number of pieces would\n        // be limitted by the RAF framerate\n        const progressTime = now - tweenInitTime > tweenDuration ? tweenDuration : Math.max(0, now - tweenInitTime);\n        const tweenedVal = tweenFunction(progressTime, activeCount, numberOfPieces, tweenDuration);\n        const numToAdd = Math.round(tweenedVal - activeCount);\n        for (let i = 0; i < numToAdd; i++) {\n          this.particles.push(this.getParticle());\n        }\n        this.particlesGenerated += numToAdd;\n      }\n      if (debug) {\n        // Draw debug text\n        context.font = '12px sans-serif';\n        context.fillStyle = '#333';\n        context.textAlign = 'right';\n        context.fillText(`Particles: ${nP}`, canvas.width - 10, canvas.height - 20);\n      }\n      // Maintain the population\n      this.particles.forEach((p, i) => {\n        // Update each particle's position\n        p.update();\n        // Prune the off-canvas particles\n        if (p.y > canvas.height || p.y < -100 || p.x > canvas.width + 100 || p.x < -100) {\n          if (recycle && activeCount <= numberOfPieces) {\n            // Replace the particle with a brand new one\n            this.particles[i] = this.getParticle();\n          } else {\n            this.removeParticleAt(i);\n          }\n        }\n      });\n      return nP > 0 || activeCount < numberOfPieces;\n    };\n    this.canvas = canvas;\n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Could not get canvas context');\n    }\n    this.context = ctx;\n    this.getOptions = getOptions;\n  }\n}\nconst confettiDefaults = {\n  width: typeof window !== 'undefined' ? window.innerWidth : 300,\n  height: typeof window !== 'undefined' ? window.innerHeight : 200,\n  numberOfPieces: 200,\n  friction: 0.99,\n  wind: 0,\n  gravity: 0.1,\n  initialVelocityX: 4,\n  initialVelocityY: 10,\n  colors: ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', '#FF5722', '#795548'],\n  opacity: 1.0,\n  debug: false,\n  tweenFunction: tweens.easeInOutQuad,\n  tweenDuration: 5000,\n  recycle: true,\n  run: true\n};\nclass Confetti {\n  constructor(canvas, opts) {\n    this.lastFrameTime = Date.now();\n    this.setOptionsWithDefaults = opts => {\n      const computedConfettiDefaults = {\n        confettiSource: {\n          x: 0,\n          y: 0,\n          w: this.canvas.width,\n          h: 0\n        }\n      };\n      this._options = {\n        ...computedConfettiDefaults,\n        ...confettiDefaults,\n        ...opts\n      };\n      Object.assign(this, opts.confettiSource);\n    };\n    this.update = () => {\n      const {\n        options: {\n          run,\n          onConfettiComplete,\n          frameRate\n        },\n        canvas,\n        context\n      } = this;\n      // Throttle the frame rate if set\n      if (frameRate) {\n        const now = Date.now();\n        const elapsed = now - this.lastFrameTime;\n        if (elapsed < 1000 / frameRate) {\n          this.rafId = requestAnimationFrame(this.update);\n          return;\n        }\n        this.lastFrameTime = now - elapsed % frameRate;\n      }\n      if (run) {\n        context.fillStyle = 'white';\n        context.clearRect(0, 0, canvas.width, canvas.height);\n      }\n      if (this.generator.animate()) {\n        this.rafId = requestAnimationFrame(this.update);\n      } else {\n        if (onConfettiComplete && typeof onConfettiComplete === 'function' && this.generator.particlesGenerated > 0) {\n          onConfettiComplete.call(this, this);\n        }\n        this._options.run = false;\n      }\n    };\n    this.reset = () => {\n      if (this.generator && this.generator.particlesGenerated > 0) {\n        this.generator.particlesGenerated = 0;\n        this.generator.particles = [];\n        this.generator.lastNumberOfPieces = 0;\n      }\n    };\n    this.stop = () => {\n      this.options = {\n        run: false\n      };\n      if (this.rafId) {\n        cancelAnimationFrame(this.rafId);\n        this.rafId = undefined;\n      }\n    };\n    this.canvas = canvas;\n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Could not get canvas context');\n    }\n    this.context = ctx;\n    this.generator = new ParticleGenerator(this.canvas, () => this.options);\n    this.options = opts;\n    this.update();\n  }\n  get options() {\n    return this._options;\n  }\n  set options(opts) {\n    const lastRunState = this._options?.run;\n    const lastRecycleState = this._options?.recycle;\n    this.setOptionsWithDefaults(opts);\n    if (this.generator) {\n      Object.assign(this.generator, this.options.confettiSource);\n      if (typeof opts.recycle === 'boolean' && opts.recycle && lastRecycleState === false) {\n        this.generator.lastNumberOfPieces = this.generator.particles.length;\n      }\n    }\n    if (typeof opts.run === 'boolean' && opts.run && lastRunState === false) {\n      this.update();\n    }\n  }\n}\nconst ref = React.createRef();\nclass ReactConfettiInternal extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvas = React.createRef();\n    this.canvas = props.canvasRef || ref;\n  }\n  componentDidMount() {\n    if (this.canvas.current) {\n      const opts = extractCanvasProps(this.props)[0];\n      this.confetti = new Confetti(this.canvas.current, opts);\n    }\n  }\n  componentDidUpdate() {\n    const confettiOptions = extractCanvasProps(this.props)[0];\n    if (this.confetti) {\n      this.confetti.options = confettiOptions;\n    }\n  }\n  componentWillUnmount() {\n    if (this.confetti) {\n      this.confetti.stop();\n    }\n    this.confetti = undefined;\n  }\n  render() {\n    const [confettiOptions, passedProps] = extractCanvasProps(this.props);\n    const canvasStyles = {\n      zIndex: 2,\n      position: 'absolute',\n      pointerEvents: 'none',\n      top: 0,\n      left: 0,\n      bottom: 0,\n      right: 0,\n      ...passedProps.style\n    };\n    return jsx(\"canvas\", {\n      width: confettiOptions.width,\n      height: confettiOptions.height,\n      ref: this.canvas,\n      ...passedProps,\n      style: canvasStyles\n    });\n  }\n}\nReactConfettiInternal.defaultProps = {\n  ...confettiDefaults\n};\nReactConfettiInternal.displayName = 'ReactConfetti';\nfunction extractCanvasProps(props) {\n  const confettiOptions = {};\n  const refs = {};\n  const rest = {};\n  const confettiOptionKeys = [...Object.keys(confettiDefaults), 'confettiSource', 'drawShape', 'onConfettiComplete', 'frameRate'];\n  const refProps = ['canvasRef'];\n  for (const prop in props) {\n    const val = props[prop];\n    if (confettiOptionKeys.includes(prop)) {\n      confettiOptions[prop] = val;\n    } else if (refProps.includes(prop)) {\n      refProps[prop] = val;\n    } else {\n      rest[prop] = val;\n    }\n  }\n  return [confettiOptions, rest, refs];\n}\nconst ReactConfetti = React.forwardRef((props, ref) => jsx(ReactConfettiInternal, {\n  canvasRef: ref,\n  ...props\n}));\nexport { ReactConfetti as default };\n//# sourceMappingURL=react-confetti.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}